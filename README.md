# Java Core
## task01:
### Практическое задание - StringBuilder

Изучите внутреннюю реализацию класса StringBuilder и напишите свою с добавлением дополнительного метода - undo().  

Прежде чем приступать - прочитайте про паттерн state и примените его в своей реализации.

## task01_2:
### Реализация task02 через паттерн Memento

# task02:
## Практическое задание - LocalDateTime

На вход вам дается время в виде класса LocalDateTime, орисуйте его в виде:

год:месяц:день##:час:минут:секунды:милисекунды

Используйте для этого аннотации jackson в спринге. И не забудьте про локаль.

# Java Collection
## task01:
### Практическое задание - Collection - фильтрация

Напишите метод filter, который принимает на вход массив любого типа, вторым арументом метод должен принимать клас, реализующий интерфейс Filter, в котором один метод - Object apply(Object o).

Метод должен быть реализован так чтобы возращать новый масив, к каждому элементу которого была применена функция apply

## task02:
### Практическое задание - Collection - count of elements

Напишите метод, который получает на вход массив элементов и возвращает Map ключи в котором - элементы, а значения - сколько раз встретился этот элемент


# Java Concurrency
## task01:
### Практическая задача - Concurrency - блокирующая очередь

Предположим, у вас есть пул потоков, и вы хотите реализовать блокирующую очередь для передачи задач между потоками. 
Создайте класс BlockingQueue, который будет обеспечивать безопасное добавление и извлечение элементов между производителями и потребителями в контексте пула потоков.

Класс BlockingQueue должен содержать методы enqueue() для добавления элемента в очередь и dequeue() для извлечения элемента. 
Если очередь пуста, dequeue() должен блокировать вызывающий поток до появления нового элемента.

Очередь должна иметь фиксированный размер.

Используйте механизмы wait() и notify() для координации между производителями и потребителями. Реализуйте метод size(), который возвращает текущий размер очереди.

## task02:
### Практическая задача - Concurrency - многопоточный банковский счет

Создайте класс BankAccount, представляющий банковский счет. 
Реализуйте методы deposit для внесения средств на счет и withdraw для снятия средств.

Класс BankAccount должен содержать синхронизированные методы deposit и withdraw для обеспечения правильной синхронизации доступа к банковскому счету. 
Реализуйте метод getBalance, возвращающий текущий баланс счета.

Создайте несколько потоков, представляющих различных клиентов банка, и дайте им возможность одновременно вносить и снимать деньги со счета.

Предусмотрите сценарии, когда один поток пытается снять средства, когда на счете недостаточно средств.

## task03:
### Практическое задание - Concurrency

Изучите следующий код, найдите в нем потенциальные проблемы и исправьте их.

## task04:
### Практическое задание - Concurrency - синхронизаторы

Синхронизация потоков с использованием CyclicBarrier и ExecutorService

В этой задаче мы будем использовать CyclicBarrier и ExecutorService для синхронизации нескольких потоков, выполняющих сложную задачу, и затем ожидающих, пока все потоки завершат выполнение, чтобы объединить результаты.

Создайте класс ComplexTask, представляющий сложную задачу, которую несколько потоков будут выполнять. В каждой задаче реализуйте метод execute(), который выполняет часть сложной задачи.

Создайте класс ComplexTaskExecutor, в котором будет использоваться CyclicBarrier и ExecutorService для синхронизации выполнения задач. 
Реализуйте метод executeTasks(int numberOfTasks), который создает пул потоков и назначает каждому потоку экземпляр сложной задачи для выполнения. 
Затем используйте CyclicBarrier для ожидания завершения всех потоков и объединения результатов их работы. В методе main создайте экземпляр ComplexTaskExecutor и вызовите метод executeTasks с несколькими задачами для выполнения.

# Java Stream API
## task01:
### Практическое задание - Stream API - генерация чисел

Предположим, у нас есть список заказов, и каждый заказ представляет собой продукт и его стоимость. Задача состоит в использовании Stream API и коллекторов для решения следующих задач:

    Создайте список заказов с разными продуктами и их стоимостями.
    Группируйте заказы по продуктам.
    Для каждого продукта найдите общую стоимость всех заказов.
    Отсортируйте продукты по убыванию общей стоимости.
    Выберите три самых дорогих продукта.
    Выведите результат: список трех самых дорогих продуктов и их общая стоимость.

## task02:
### Практическое задачние - Stream API - агрегация и объединение результатов

    Создайте коллекцию студентов, где каждый студент содержит информацию о предметах, которые он изучает, и его оценках по этим предметам.
    Используйте Parallel Stream для обработки данных и создания Map, где ключ - предмет, а значение - средняя оценка по всем студентам.
    Выведите результат: общую Map с средними оценками по всем предметам.

## task03:
### Практическое задание - Stream API - ForkJoinPool: Рекурсивное вычисление факториала

Рассмотрим задачу вычисления факториала числа с использованием ForkJoinPool. Факториал числа n обозначается как n! и вычисляется как произведение всех положительных целых чисел от 1 до n.

    Реализуйте класс FactorialTask, который расширяет RecursiveTask. Этот класс будет выполнять рекурсивное вычисление факториала числа.
    В конструкторе FactorialTask передайте число n, факториал которого нужно вычислить.
    В методе compute() разбейте задачу на подзадачи и используйте fork() для их асинхронного выполнения.
    Используйте join() для получения результатов подзадач и комбинирования их для получения общего результата.
    В основном методе создайте экземпляр FactorialTask с числом, для которого нужно вычислить факториал, и запустите его в ForkJoinPool.
    Выведите результат вычисления факториала.

# Java Maven
## task01:
### Практическое задание maven

Задача: Разработка библиотеки для работы с геометрическими фигурами.

1 Создайте новый проект "GeometryLibrary", в котором определите классы для представления геометрических фигур, таких как круг, прямоугольник и треугольник. Каждая фигура должна иметь методы для вычисления площади и периметра.

2 В проекте "GeometryApp" создайте приложение, которое использует библиотеку "GeometryLibrary". Создайте объекты различных геометрических фигур, выведите информацию о их площади и периметре.

3 Дополнительное задание: Управление версиями.

Установите версию проекта "GeometryLibrary" на 1.0.0. Внесите небольшие изменения в код библиотеки и обновите версию на 1.1.0. В проекте "GeometryApp" обновите зависимость на новую версию библиотеки.

4 Управление зависимостями и конфликтами.

Создайте модуль "GeometryUtils" в проекте "GeometryLibrary", в котором определите дополнительные функции для манипуляций с геометрическими данными (например, преобразование единиц измерения, сравнение фигур и т.д.).

Установите версию "GeometryUtils" в "1.0.0-SNAPSHOT".

В проекте "GeometryApp" добавьте зависимость от "GeometryUtils" и используйте его функциональность.

В модуле "GeometryUtils" внесите изменения и увеличьте версию до "1.1.0-SNAPSHOT".

В проекте "GeometryApp" попробуйте обновить зависимость "GeometryUtils" до новой версии и решите конфликты зависимостей.

Дополнительное задание:

В модуле "GeometryLibrary" добавьте поддержку трехмерных фигур (куб, сфера и т.д.) с новым модулем "ThreeDimensionalShapes".

Установите версию "ThreeDimensionalShapes" в "1.0.0-SNAPSHOT".

Обновите проект "GeometryApp" так, чтобы он мог использовать как двухмерные, так и трехмерные фигуры.

При обновлении версии "ThreeDimensionalShapes" до "1.1.0-SNAPSHOT", решите возможные конфликты зависимостей.

# Spring MVC
## task01:
### Практическое задание - Spring MVC - json view

Разработайте RESTful API для управления информацией о пользователях и их заказах в интернет-магазине. 
Используйте аннотацию @JsonView для определения различных представлений JSON в зависимости от контекста.

#### Сущности:

User: содержит информацию о пользователе, такую как имя, адрес электронной почты, идентификатор и т.д.

Order: представляет заказ пользователя и содержит информацию о товарах, сумме заказа и статусе.

#### Реализация CRUD операций:

    Создайте CRUD операции для пользователей и их заказов с использованием Spring Data JPA.

    RESTful API:

    Реализуйте RESTful эндпоинты для:

    Получения списка всех пользователей (без деталей заказов).

    Получения информации о конкретном пользователе (включая детали заказов).

    Создания нового пользователя.

    Обновления информации о пользователе.

    Удаления пользователя.

Используйте @JsonView для определения различных представлений JSON в зависимости от контекста:

Создайте интерфейсы представлений, например, Views.UserSummary и Views.UserDetails.

Настройте их в соответствии с вашими потребностями (например, в представлении UserSummary отображать только базовую информацию о пользователе, а в UserDetails включать также детали заказов).

#### Обработка ошибок и валидация:

Обеспечьте корректную обработку ошибок и возвращение соответствующих HTTP-статусов.

Добавьте валидацию входных данных, такую как проверка корректности электронной почты.

#### Тестирование:

Напишите модульные тесты для вашего кода, уделяя внимание различным представлениям JSON при использовании @JsonView.

## task02:
### Практическое задание - Spring MVC - библиотека

Задача: RESTful API для управления книгами в библиотеке с использованием Pageable

Создайте сущности Book и Author с соответствующими атрибутами.

Реализуйте CRUD (Create, Read, Update, Delete) операции для книг с использованием Spring Data JPA.

Создайте контроллер для обработки HTTP-запросов, связанных с книгами, в виде RESTful API.
Реализуйте эндпоинты для:

    Получения списка всех книг с возможностью сортировки и пагинации. Используйте Pageable для указания страницы и размера страницы.

    Получения информации о конкретной книге.

    Добавления новых книг.

    Обновления информации о книге.

    Удаления книги.

    Используйте аннотации Spring, такие как @RestController, @GetMapping, @PostMapping, @PutMapping и @DeleteMapping для явного указания операций.

    Обеспечьте правильную обработку ошибок, возвращая соответствующие HTTP-статусы и сообщения об ошибках.

    Проверьте, что пагинация работает корректно с использованием Pageable при запросах на получение списка книг.

## task03:
### Практическое задание - MVC - Object mapper

Разработайте систему для управления заказами в онлайн-магазине с использованием ObjectMapper для преобразования объектов в формат JSON и обратно.
Сущности:

Product: содержит информацию о продукте, такую как название, описание, цена и количество на складе.

Order: представляет заказ пользователя и содержит информацию о товарах, адресе доставки, стоимости и статусе заказа.

Customer: представляет пользователя, размещающего заказ, и содержит информацию о имени, адресе электронной почты и контактном номере.
Операции:

Реализуйте операции для чтения, создания, обновления и удаления продуктов и заказов, используя Spring Data JPA.
RESTful API:

    Создайте RESTful эндпоинты для:

    Получения списка всех продуктов в магазине.

    Получения информации о конкретном продукте.

    Создания нового продукта.

    Обновления информации о продукте.

    Удаления продукта.

    Оформления нового заказа.

    Получения информации о конкретном заказе.

ObjectMapper:

Используйте ObjectMapper для преобразования объектов Product, Order и Customer в формат JSON и обратно.

При создании нового продукта и размещении заказа через REST API, принимайте данные в формате JSON и преобразуйте их в соответствующие объекты.

При возвращении информации о продуктах и заказах через REST API, преобразуйте объекты Product, Order и Customer в JSON.
Обработка ошибок и валидация:

Обеспечьте корректную обработку ошибок и возвращение соответствующих HTTP-статусов.

Добавьте валидацию входных данных, такую как проверка обязательных полей и формата данных.
Сущности

Product (Продукт):

productId (идентификатор продукта) name (название продукта) description (описание продукта) price (цена продукта) quantityInStock (количество на складе)

Customer (Покупатель):

customerId (идентификатор покупателя) firstName (имя покупателя) lastName (фамилия покупателя) email (адрес электронной почты покупателя) contactNumber (контактный номер телефона покупателя)

Order (Заказ):

orderId (идентификатор заказа) customer (ссылка на объект Customer) products (список продуктов в заказе) orderDate (дата размещения заказа) shippingAddress (адрес доставки) totalPrice (общая стоимость заказа) orderStatus (статус заказа)