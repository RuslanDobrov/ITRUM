# Java Core
## task01:
### Практическое задание - StringBuilder

Изучите внутреннюю реализацию класса StringBuilder и напишите свою с добавлением дополнительного метода - undo().  

Прежде чем приступать - прочитайте про паттерн state и примените его в своей реализации.

## task01_2:
### Реализация task02 через паттерн Memento

# task02:
## Практическое задание - LocalDateTime

На вход вам дается время в виде класса LocalDateTime, орисуйте его в виде:

год:месяц:день##:час:минут:секунды:милисекунды

Используйте для этого аннотации jackson в спринге. И не забудьте про локаль.

# Java Collection
## task01:
### Практическое задание - Collection - фильтрация

Напишите метод filter, который принимает на вход массив любого типа, вторым арументом метод должен принимать клас, реализующий интерфейс Filter, в котором один метод - Object apply(Object o).

Метод должен быть реализован так чтобы возращать новый масив, к каждому элементу которого была применена функция apply

## task02:
### Практическое задание - Collection - count of elements

Напишите метод, который получает на вход массив элементов и возвращает Map ключи в котором - элементы, а значения - сколько раз встретился этот элемент


# Java Concurrency
## task01:
### Практическая задача - Concurrency - блокирующая очередь

Предположим, у вас есть пул потоков, и вы хотите реализовать блокирующую очередь для передачи задач между потоками. 
Создайте класс BlockingQueue, который будет обеспечивать безопасное добавление и извлечение элементов между производителями и потребителями в контексте пула потоков.

Класс BlockingQueue должен содержать методы enqueue() для добавления элемента в очередь и dequeue() для извлечения элемента. 
Если очередь пуста, dequeue() должен блокировать вызывающий поток до появления нового элемента.

Очередь должна иметь фиксированный размер.

Используйте механизмы wait() и notify() для координации между производителями и потребителями. Реализуйте метод size(), который возвращает текущий размер очереди.

## task02:
### Практическая задача - Concurrency - многопоточный банковский счет

Создайте класс BankAccount, представляющий банковский счет. 
Реализуйте методы deposit для внесения средств на счет и withdraw для снятия средств.

Класс BankAccount должен содержать синхронизированные методы deposit и withdraw для обеспечения правильной синхронизации доступа к банковскому счету. 
Реализуйте метод getBalance, возвращающий текущий баланс счета.

Создайте несколько потоков, представляющих различных клиентов банка, и дайте им возможность одновременно вносить и снимать деньги со счета.

Предусмотрите сценарии, когда один поток пытается снять средства, когда на счете недостаточно средств.

## task03:
### Практическое задание - Concurrency

Изучите следующий код, найдите в нем потенциальные проблемы и исправьте их.

## task04:
### Практическое задание - Concurrency - синхронизаторы

Синхронизация потоков с использованием CyclicBarrier и ExecutorService

В этой задаче мы будем использовать CyclicBarrier и ExecutorService для синхронизации нескольких потоков, выполняющих сложную задачу, и затем ожидающих, пока все потоки завершат выполнение, чтобы объединить результаты.

Создайте класс ComplexTask, представляющий сложную задачу, которую несколько потоков будут выполнять. В каждой задаче реализуйте метод execute(), который выполняет часть сложной задачи.

Создайте класс ComplexTaskExecutor, в котором будет использоваться CyclicBarrier и ExecutorService для синхронизации выполнения задач. 
Реализуйте метод executeTasks(int numberOfTasks), который создает пул потоков и назначает каждому потоку экземпляр сложной задачи для выполнения. 
Затем используйте CyclicBarrier для ожидания завершения всех потоков и объединения результатов их работы. В методе main создайте экземпляр ComplexTaskExecutor и вызовите метод executeTasks с несколькими задачами для выполнения.

# Java Stream API
## task01:
### Практическое задание - Stream API - генерация чисел

Предположим, у нас есть список заказов, и каждый заказ представляет собой продукт и его стоимость. Задача состоит в использовании Stream API и коллекторов для решения следующих задач:

    Создайте список заказов с разными продуктами и их стоимостями.
    Группируйте заказы по продуктам.
    Для каждого продукта найдите общую стоимость всех заказов.
    Отсортируйте продукты по убыванию общей стоимости.
    Выберите три самых дорогих продукта.
    Выведите результат: список трех самых дорогих продуктов и их общая стоимость.

## task02:
### Практическое задачние - Stream API - агрегация и объединение результатов

    Создайте коллекцию студентов, где каждый студент содержит информацию о предметах, которые он изучает, и его оценках по этим предметам.
    Используйте Parallel Stream для обработки данных и создания Map, где ключ - предмет, а значение - средняя оценка по всем студентам.
    Выведите результат: общую Map с средними оценками по всем предметам.

## task03:
### Практическое задание - Stream API - ForkJoinPool: Рекурсивное вычисление факториала

Рассмотрим задачу вычисления факториала числа с использованием ForkJoinPool. Факториал числа n обозначается как n! и вычисляется как произведение всех положительных целых чисел от 1 до n.

    Реализуйте класс FactorialTask, который расширяет RecursiveTask. Этот класс будет выполнять рекурсивное вычисление факториала числа.
    В конструкторе FactorialTask передайте число n, факториал которого нужно вычислить.
    В методе compute() разбейте задачу на подзадачи и используйте fork() для их асинхронного выполнения.
    Используйте join() для получения результатов подзадач и комбинирования их для получения общего результата.
    В основном методе создайте экземпляр FactorialTask с числом, для которого нужно вычислить факториал, и запустите его в ForkJoinPool.
    Выведите результат вычисления факториала.


